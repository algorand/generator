## Map generated name from spec to hand written name
#macro ( paramName $param )
$str.kebabToCamel($param.propertyName.replaceAll("_", "-"))##
#end
## Converts a parameter type into the SDK specific type.
#macro ( toSdkType $className $param $isArgType )
#set( $d = "$" )
#set( $e = "!" )
#set( $type_override_variable = "${d}${e}propFile.type_override_${className}_#paramName(${param})" )
#set( $type_override = "#evaluate($type_override_variable)" )
#if ( $param.algorandFormat == "SignedTransaction" )
SignedTransaction##
#elseif ( $param.algorandFormat == "Address" )
#if ( $isArgType )
(Address | string)##
#else
Address##
#end
#elseif ( $param.algorandFormat == "BlockHeader" )
BlockHeader##
#elseif ( $type_override == "bigint" || ( $param.algorandFormat == "uint64" && $type_override.length() == 0 ) )
#if ( $isArgType )
(number | bigint)##
#else
bigint##
#end
#elseif ( $param.type == "object" )
UntypedValue##
#elseif ( $type_override == "number" || ( ( $param.type == "integer" || $param.arrayType == "integer" ) && $type_override.length() == 0 ) )
#if ( $isArgType )
(number | bigint)##
#else
number##
#end
#elseif ( $param.type == "boolean" )
boolean##
#elseif( $param.type == "address" )
string##
#elseif( $param.type == "binary" )
Uint8Array##
#elseif($param.arrayType && $param.format == "byte")
Uint8Array##
#elseif( $param.type == "string" && $param.format == "byte" )
#if ( $isArgType )
string | Uint8Array##
#else
Uint8Array##
#end
#elseif( $param.type == "string" || $param.arrayType == "string" )
string##
#elseif( $param.arrayType )
${param.arrayType}##
#elseif( $param.refType )## This is second because the old code avoids typedef of references
${param.refType}##
#else
UNHANDLED TYPE
- ref: $!param.refType
- type: $!param.type
- array type: $!param.arrayType
- algorand format: $!param.algorandFormat
- format: $!param.format
$unknown.type ## force a template failure with an unknown type
#end
#if ($param.arrayType && $param.arrayType != "")[]#end## Add array postfix to arrays...
#end
## Converts a parameter type into the SDK specific type.
#macro ( toSchema $className $param )
#if ( $param.arrayType )
new ArraySchema(##
#end
#if ( $param.algorandFormat == "BlockHeader" )
BLOCK_HEADER_SCHEMA##
#elseif ( $param.algorandFormat == "SignedTransaction" )
SignedTransaction.encodingSchema##
#elseif ( $param.type == "object" || $param.arrayType == "object" )
UntypedValue.encodingSchema##
#elseif ( $param.algorandFormat == "Address" )
new StringSchema()## # To comply with existing msgpack REST API behavior, encode addresses as strings
#elseif ( $param.algorandFormat == "uint64" || $param.type == "integer" || $param.arrayType == "integer" )
new Uint64Schema()##
#elseif ( $param.type == "boolean" || $param.arrayType == "boolean" )
new BooleanSchema()##
#elseif( ( $param.type == "string" || $param.arrayType == "string" ) && ( $param.format == "byte" || $param.format == "binary" ) )
new ByteArraySchema()##
#elseif( $param.type == "string" || $param.arrayType == "string" )
new StringSchema()##
#elseif ( "#isClassType($param)" == "true" )
#if ( $param.arrayType )
#set( $propClassName = $param.arrayType )
#else
#set( $propClassName = $param.refType )
#end
${propClassName}.encodingSchema##
#else
UNHANDLED SCHEMA TYPE
- className: $className
- property: $param
- isClassType: #isClassType($param)
$unknown.type ## force a template failure with an unknown type
#end
#if ( $param.arrayType )
)##
#end
#end
## Check if there's a class associated with this type
#macro ( isClassType $param )
#if ( $param.algorandFormat == "SignedTransaction" )
false##
#elseif ( $param.algorandFormat == "Address" )
false##
#elseif ( $param.algorandFormat == "BlockHeader" )
false##
#elseif ( $param.algorandFormat == "uint64" )
false##
#elseif ( $param.type == "object" )
false##
#elseif ( $param.type == "integer" || $param.arrayType == "integer" )
false##
#elseif ( $param.type == "boolean" )
false##
#elseif( $param.type == "address" )
false##
#elseif( $param.type == "binary" )
false##
#elseif($param.arrayType && $param.format == "byte")
false##
#elseif( $param.type == "string" && $param.format == "byte" )
false##
#elseif( $param.type == "string" || $param.arrayType == "string" )
false##
#else
true##
#end
#end
## Create an expression to assign a field in a constructor
#macro ( constructorAssignType $className $prop )
#set( $argType = "#toSdkType($className, $prop, true)" )
#set( $fieldType = "#toSdkType($className, $prop, false)" )
#set( $name = "#paramName($prop)" )
#if ( $argType == $fieldType )
$name##
#elseif ( $argType == "(Address | string)" && $fieldType == "Address" )
typeof $name === 'string' ? Address.fromString($name) : $name##
#elseif ( $argType == "(Address | string)[]" && $fieldType == "Address[]" )
#if ( $prop.required )
${name}.map(addr => typeof addr === 'string' ? Address.fromString(addr) : addr)##
#else
typeof $name !== 'undefined' ? ${name}.map(addr => typeof addr === 'string' ? Address.fromString(addr) : addr) : undefined##
#end
#elseif ( $argType == "string | Uint8Array" && $fieldType == "Uint8Array" )
typeof $name === 'string' ? base64ToBytes($name) : $name##
#elseif ( $argType == "(number | bigint)" && $fieldType == "bigint" )
#if ( $prop.required )
ensureBigInt($name)##
#else
typeof $name === 'undefined' ? undefined : ensureBigInt($name)##
#end
#elseif ( $argType == "(number | bigint)[]" && $fieldType == "bigint[]" )
#if ( $prop.required )
${name}.map(ensureBigInt)##
#else
typeof ${name} === 'undefined' ? undefined : ${name}.map(ensureBigInt)##
#end
#elseif ( $argType == "(number | bigint)" && $fieldType == "number" )
#if ( $prop.required )
ensureSafeInteger($name)##
#else
typeof $name === 'undefined' ? undefined : ensureSafeInteger($name)##
#end
#elseif ( $argType == "(number | bigint)[]" && $fieldType == "number[]" )
#if ( $prop.required )
${name}.map(ensureSafeInteger)##
#else
typeof ${name} === 'undefined' ? undefined : ${name}.map(ensureSafeInteger)##
#end
#else
UNHANDLED CONSTRUCTOR TYPE CONVERSION
- property: $prop
- propertyName: $name
- argType: $argType
- fieldType type: $fieldType
$unknown.type ## force a template failure with an unknown type
#end
#end
## Create an expression which checks if a field should be included in msgpackPrepare
#macro ( shouldMsgpackPrepareOptionalField $prop )
#set( $value = "this.#paramName($prop)" )
#if ( $prop.arrayType )
$value && ${value}.length##
#else
$value##
#end
#end
## Create an expression to assign a field in the toEncodingData function
#macro ( fieldToEncodingData $prop )## TODO: combine shouldMsgpackPrepareOptionalField with this, like fromEncodingDataAssignType
#set( $value = "this.#paramName($prop)" )
#if ( $prop.algorandFormat == "BlockHeader" )
blockHeaderToEncodingData($value)##
#elseif ( $prop.algorandFormat == "Address" || $prop.type == "Address" )
#if ( $prop.arrayType )
${value}.map(addr => addr.toString())##
#else
${value}.toString()##
#end
#elseif ( "#isClassType($prop)" == "false" && $prop.algorandFormat != "SignedTransaction" && $prop.type != "object" )
$value##
#elseif ( $prop.arrayType )
${value}.map(v => v.toEncodingData())##
#else
${value}.toEncodingData()##
#end
#end
## Create an expression to assign a field in the fromEncodingData function
#macro ( fromEncodingDataAssignType $value $prop $className )
#set( $sdkType = "#toSdkType($className, $prop, false)" )
#if ( $sdkType == "SignedTransaction[]" )
#set ( $sdkType = "SignedTransaction" )
#end
#if ( $prop.algorandFormat == "BlockHeader" )
blockHeaderFromEncodingData($value)##
#elseif ( "#isClassType($prop)" == "false" && $sdkType != "SignedTransaction" && $sdkType != "UntypedValue")
$value##
#elseif ( $prop.arrayType )
#if ( $sdkType == "SignedTransaction" || $sdkType == "UntypedValue")
#set ( $mapping = ".map(${sdkType}.fromEncodingData)" )
#else
#set ( $mapping = ".map(${prop.arrayType}.fromEncodingData)" )
#end
#if ($prop.required)
($value ?? [])$mapping##
#else
typeof $value !== 'undefined' ? $value$mapping : undefined##
#end
#else
#if ( $sdkType == "SignedTransaction" || $sdkType == "UntypedValue")
#set ( $assignment = "${sdkType}.fromEncodingData" )
#else
#set ( $assignment = "${prop.refType}.fromEncodingData" )
#end
#if ($prop.required)
$assignment($value ?? {})##
#else
typeof $value !== 'undefined' ? $assignment($value) : undefined##
#end
#end
#end
#macro ( questionMarkIfOptional $param )
#if ( ! $param.required )
?##
#end
#end
#set( $new = "
" )
#set( $object_gt = $propFile.use_object_params_if_greater_than )
#set( $Integer = 0 )
/**
 * NOTICE: This file was generated. Editing this file manually is not recommended.
 */

/* eslint-disable no-use-before-define */
import { ensureBigInt, ensureSafeInteger } from '../../../../utils/utils.js';
import { Encodable, Schema } from '../../../../encoding/encoding.js';
import { NamedMapSchema, ArraySchema, Uint64Schema, StringSchema, BooleanSchema, ByteArraySchema } from '../../../../encoding/schema/index.js';
import { base64ToBytes } from '../../../../encoding/binarydata.js';
#if ( $propFile.indexer == "false" )
import BlockHeader, { blockHeaderFromEncodingData, blockHeaderToEncodingData, BLOCK_HEADER_SCHEMA } from '../../../../types/blockHeader.js';
import { SignedTransaction } from '../../../../signedTransaction.js';
#end
import { Address } from '../../../../encoding/address.js';
import { UntypedValue } from '../../untypedmodel.js';

#foreach( $modelEntry in $models.entrySet() )
#set( $def = $modelEntry.key )
#set( $props = $def.propertiesSortedByRequired )
#set( $d = "$" )
#set( $e = "!" )
#set( $override_variable_name = "${d}${e}propFile.override_${def.name}_order" )
#set( $preferred_order_str = "#evaluate($override_variable_name)" )
#if ( $preferred_order_str.length() > 0 )
#set( $preferred_order = $preferred_order_str.split(",") )
#set( $props = $order.propertiesWithOrdering($props, $preferred_order) )
#end
#set( $use_object_params = $props.size() > $Integer.parseInt($object_gt) )
#if ($def.doc)
/**
 * $str.formatDoc($def.doc, " * ")
 */
#end
export class $def.name implements Encodable {

  private static encodingSchemaValue: Schema | undefined;

  static get encodingSchema(): Schema {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      (this.encodingSchemaValue as NamedMapSchema).entries.push(
#foreach( $prop in $props )
        { key: '$prop.propertyName', valueSchema: #toSchema($def.name, $prop), required: $prop.required, omitEmpty: true },
#end
      );
    }
    return this.encodingSchemaValue;
  }

#foreach( $prop in $props )
#if ( !$prop.doc.isEmpty() )
  /**
   * $str.formatDoc($prop.doc, "   * ")
   */
#end
  public #paramName($prop)#questionMarkIfOptional($prop): #toSdkType($def.name, $prop, false);

#end
  /**
   * Creates a new `$def.name` object.
#foreach( $prop in $props )
   * @param #paramName($prop) - $str.formatDoc($prop.doc, "   * ")
#end
   */
#if ($use_object_params)
  constructor({
#else
  constructor(
#end
#foreach( $prop in $props )
#if ($use_object_params)
    #paramName($prop),
#else
    #paramName($prop)#questionMarkIfOptional($prop): #toSdkType($def.name, $prop, true),
#end
#end
#if ($use_object_params)
  }: {
#foreach ( $prop in $props )
    #paramName($prop)#questionMarkIfOptional($prop): #toSdkType($def.name, $prop, true)

#end
  }) {
#else
  ) {
#end
#foreach( $prop in $props )
#set( $var = "#paramName($prop)" )
    this.$var = #constructorAssignType($def.name, $prop);
#end
  }

  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema(): Schema {
    return ${def.name}.encodingSchema;
  }

  toEncodingData(): Map<string, unknown> {
    const data = new Map<string, unknown>([
#foreach( $prop in $props )
#if ( $prop.required )
    ['$prop.propertyName', #fieldToEncodingData($prop)],
#end
#end
    ]);
#foreach( $prop in $props )
#if ( ! $prop.required )
    if (#shouldMsgpackPrepareOptionalField($prop)) {
      data.set('$prop.propertyName', #fieldToEncodingData($prop));
    }
#end
#end
    return data;
  }

  static fromEncodingData(data: unknown): $def.name {
#set ( $d = "$" )## Create a variable in order to insert a $ into the code
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded logic sig account: ${d}{data}`);
    }
#if ($use_object_params)
    return new ${def.name}({
#foreach( $prop in $props )
      #paramName($prop): #fromEncodingDataAssignType("data.get('$prop.propertyName')", $prop, $def.name),
#end
    });
#else
    return new ${def.name}(
#foreach( $prop in $props )
      #fromEncodingDataAssignType("data.get('$prop.propertyName')", $prop, $def.name),
#end
    );
#end
  }
}

#end
