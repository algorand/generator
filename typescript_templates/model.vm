## Map generated name from spec to hand written name
#macro ( paramName $param )
$str.kebabToCamel($param.propertyName.replaceAll("_", "-"))##
#end
## Converts a parameter type into the SDK specific type.
#macro ( toSdkType $className $param $isArgType )
#set( $d = "$" )
#set( $e = "!" )
#set( $type_override_variable = "${d}${e}propFile.type_override_${className}_#paramName(${param})" )
#set( $type_override = "#evaluate($type_override_variable)" )
#if ( $param.algorandFormat == "SignedTransaction" )
SignedTransaction##
#elseif ( $param.algorandFormat == "Address" )## No special handling for Address in go SDK
string##
#elseif ( $param.algorandFormat == "BlockHeader" )
BlockHeader##
#elseif ( $type_override == "bigint" || ( $param.algorandFormat == "uint64" && $type_override.length() == 0 ) )
#if ( $isArgType )
(number | bigint)##
#else
bigint##
#end
#elseif ( $param.type == "object" )
Map<string, MsgpackEncodingData>##
#elseif ( $type_override == "number" || ( ( $param.type == "integer" || $param.arrayType == "integer" ) && $type_override.length() == 0 ) )
#if ( $isArgType )
(number | bigint)##
#else
number##
#end
#elseif ( $param.type == "boolean" )
boolean##
#elseif( $param.type == "address" )
string##
#elseif( $param.type == "binary" )
Uint8Array##
#elseif($param.arrayType && $param.format == "byte")
Uint8Array##
#elseif( $param.type == "string" && $param.format == "byte" )
#if ( $isArgType )
string | Uint8Array##
#else
Uint8Array##
#end
#elseif( $param.type == "string" || $param.arrayType == "string" )
string##
#elseif( $param.arrayType )
${param.arrayType}##
#elseif( $param.refType )## This is second because the old code avoids typedef of references
${param.refType}##
#else
UNHANDLED TYPE
- ref: $!param.refType
- type: $!param.type
- array type: $!param.arrayType
- algorand format: $!param.algorandFormat
- format: $!param.format
$unknown.type ## force a template failure with an unknown type
#end
#if ($param.arrayType && $param.arrayType != "")[]#end## Add array postfix to arrays...
#end
## Check if there's a class associated with this type
#macro ( isClassType $param )
#if ( $param.algorandFormat == "SignedTransaction" )
false##
#elseif ( $param.algorandFormat == "Address" )
false##
#elseif ( $param.algorandFormat == "BlockHeader" )
false##
#elseif ( $param.algorandFormat == "uint64" )
false##
#elseif ( $param.type == "object" )
false##
#elseif ( $param.type == "integer" || $param.arrayType == "integer" )
false##
#elseif ( $param.type == "boolean" )
false##
#elseif( $param.type == "address" )
false##
#elseif( $param.type == "binary" )
false##
#elseif($param.arrayType && $param.format == "byte")
false##
#elseif( $param.type == "string" && $param.format == "byte" )
false##
#elseif( $param.type == "string" || $param.arrayType == "string" )
false##
#else
true##
#end
#end
## Create an expression to assign a field in a constructor
#macro ( constructorAssignType $className $prop )
#set( $argType = "#toSdkType($className, $prop, true)" )
#set( $fieldType = "#toSdkType($className, $prop, false)" )
#set( $name = "#paramName($prop)" )
#if ( $argType == $fieldType )
$name##
#elseif ( $argType == "string | Uint8Array" && $fieldType == "Uint8Array" )
typeof $name === 'string' ? base64ToBytes($name) : $name##
#elseif ( $argType == "(number | bigint)" && $fieldType == "bigint" )
#if ( $prop.required )
ensureBigInt($name)##
#else
typeof $name === 'undefined' ? undefined : ensureBigInt($name)##
#end
#elseif ( $argType == "(number | bigint)[]" && $fieldType == "bigint[]" )
#if ( $prop.required )
${name}.map(ensureBigInt)##
#else
typeof ${name} === 'undefined' ? undefined : ${name}.map(ensureBigInt)##
#end
#elseif ( $argType == "(number | bigint)" && $fieldType == "number" )
#if ( $prop.required )
ensureSafeInteger($name)##
#else
typeof $name === 'undefined' ? undefined : ensureSafeInteger($name)##
#end
#elseif ( $argType == "(number | bigint)[]" && $fieldType == "number[]" )
#if ( $prop.required )
${name}.map(ensureSafeInteger)##
#else
typeof ${name} === 'undefined' ? undefined : ${name}.map(ensureSafeInteger)##
#end
#else
UNHANDLED CONSTRUCTOR TYPE CONVERSION
- property: $prop
- propertyName: $name
- argType: $argType
- fieldType type: $fieldType
$unknown.type ## force a template failure with an unknown type
#end
#end
## Create an expression which checks if a field should be included in msgpackPrepare
#macro ( shouldMsgpackPrepareOptionalField $prop )
#set( $value = "this.#paramName($prop)" )
#if ( $prop.arrayType )
$value && ${value}.length##
#else
$value##
#end
#end
## Create an expression to assign a field in the msgpackPrepare function
#macro ( msgpackPrepareField $prop )
#set( $value = "this.#paramName($prop)" )
#if ( $prop.algorandFormat == "BlockHeader" )
blockHeaderMsgpackPrepare($value)##
#elseif ( "#isClassType($prop)" == "false" && $prop.algorandFormat != "SignedTransaction" )
$value##
#elseif ( $prop.arrayType )
${value}.map(v => v.msgpackPrepare())##
#else
${value}.msgpackPrepare()##
#end
#end
## Create an expression to assign a field in the jsonPrepare function
#macro ( jsonPrepareField $className $prop )
#set( $value = "this.#paramName($prop)" )
#set( $sdkType = "#toSdkType($className, $prop, false)" )
#if ( $prop.algorandFormat == "BlockHeader" )
$value##
#elseif ( "#isClassType($prop)" == "false" && $prop.algorandFormat != "SignedTransaction" && $sdkType != "Uint8Array" && $sdkType != "Uint8Array[]")
$value##
#elseif ( $prop.arrayType )
#if ( $sdkType == "Uint8Array[]" )
${value}.map(bytesToBase64)##
#else
${value}.map(v => v.jsonPrepare())##
#end
#elseif ( $sdkType == "Uint8Array" )
bytesToBase64($value)##
#else
${value}.jsonPrepare()##
#end
#end
## Create an expression to assign a field in the fromDecodedMsgpack function
#macro ( fromDecodedMsgpackAssignType $value $prop $className )
#if ( $prop.algorandFormat == "BlockHeader" )
blockHeaderFromDecodedMsgpack($value)##
#elseif ( "#isClassType($prop)" == "false" && $prop.algorandFormat != "SignedTransaction" )
#if ($prop.required)
$value ?? #defaultValueForType($className, $prop)##
#else
$value##
#end
#elseif ( $prop.arrayType )
#if ( $prop.algorandFormat == "SignedTransaction" )
#set ( $mapping = ".map(SignedTransaction.fromDecodedMsgpack)" )
#else
#set ( $mapping = ".map(${prop.arrayType}.fromDecodedMsgpack)" )
#end
#if ($prop.required)
($value ?? [])$mapping##
#else
typeof $value !== 'undefined' ? $value$mapping : undefined##
#end
#else
#if ( $prop.algorandFormat == "SignedTransaction" )
#set ( $assignment = "SignedTransaction.fromDecodedMsgpack" )
#else
#set ( $assignment = "${prop.refType}.fromDecodedMsgpack" )
#end
#if ($prop.required)
$assignment($value ?? {})##
#else
typeof $value !== 'undefined' ? $assignment($value) : undefined##
#end
#end
#end
## Create an expression to assign a field in the fromDecodedJSON function
#macro ( fromDecodedJSONAssignType $value $prop $className )
#if ( $prop.algorandFormat == "BlockHeader" )
$value as BlockHeader##
#elseif ( "#isClassType($prop)" == "false" && $prop.algorandFormat != "SignedTransaction" )
#if ($prop.required)
$value ?? #defaultValueForType($className, $prop)##
#else
$value##
#end
#elseif ( $prop.arrayType )
#if ( $prop.algorandFormat == "SignedTransaction" )
#set ( $mapping = ".map(SignedTransaction.fromDecodedJSON)" )
#else
#set ( $mapping = ".map(${prop.arrayType}.fromDecodedJSON)" )
#end
#if ($prop.required)
($value ?? [])$mapping##
#else
typeof $value !== 'undefined' ? $value$mapping : undefined##
#end
#else
#if ( $prop.algorandFormat == "SignedTransaction" )
#set ( $assignment = "SignedTransaction.fromDecodedJSON" )
#else
#set ( $assignment = "${prop.refType}.fromDecodedJSON" )
#end
#if ($prop.required)
$assignment($value ?? {})##
#else
typeof $value !== 'undefined' ? $assignment($value) : undefined##
#end
#end
#end
#macro ( defaultValueForType $className $prop )
#set( $sdkType = "#toSdkType($className, $prop, false)" )
#if ( $prop.arrayType )
[]##
#elseif ( $sdkType == "string" )
""##
#elseif ( $sdkType == "number" || $sdkType == "bigint" )## Any bigint type will accept numbers anyway
0##
#elseif ( $sdkType == "boolean" )
false##
#elseif ( $sdkType == "Uint8Array" )
new Uint8Array()##
#elseif ( $sdkType == "BlockHeader" || $sdkType == "Map<string, MsgpackEncodingData>" || $sdkType == "SignedTransaction" )
{}##
#else
UNHANDLED DEFAULT TYPE
- class: $className
- property: $prop
- sdkType: $sdkType
$unknown.type ## force a template failure with an unknown type
#end
#end
#macro ( questionMarkIfOptional $param )
#if ( ! $param.required )
?##
#end
#end
#set( $new = "
" )
#set( $object_gt = $propFile.use_object_params_if_greater_than )
#set( $Integer = 0 )
/**
 * NOTICE: This file was generated. Editing this file manually is not recommended.
 */

/* eslint-disable no-use-before-define */
import { ensureBigInt, ensureSafeInteger } from '../../../../utils/utils.js';
import { MsgpackEncodable, MsgpackEncodingData, JSONEncodable, JSONEncodingData } from '../../../../encoding/encoding.js';
import { base64ToBytes, bytesToBase64 } from '../../../../encoding/binarydata.js';
#if ( $propFile.indexer == "false" )
import BlockHeader, { blockHeaderMsgpackPrepare, blockHeaderFromDecodedMsgpack } from '../../../../types/blockHeader.js';
import { SignedTransaction } from '../../../../signedTransaction.js';
#end
// import BaseModel from '../../basemodel.js';

#foreach( $modelEntry in $models.entrySet() )
#set( $def = $modelEntry.key )
#set( $props = $def.propertiesSortedByRequired )
#set( $d = "$" )
#set( $e = "!" )
#set( $override_variable_name = "${d}${e}propFile.override_${def.name}_order" )
#set( $preferred_order_str = "#evaluate($override_variable_name)" )
#if ( $preferred_order_str.length() > 0 )
#set( $preferred_order = $preferred_order_str.split(",") )
#set( $props = $order.propertiesWithOrdering($props, $preferred_order) )
#end
#set( $use_object_params = $props.size() > $Integer.parseInt($object_gt) )
#if ($def.doc)
/**
 * $str.formatDoc($def.doc, " * ")
 */
#end
export class $def.name implements MsgpackEncodable, JSONEncodable {
#foreach( $prop in $props )
#if ( !$prop.doc.isEmpty() )
  /**
   * $str.formatDoc($prop.doc, "   * ")
   */
#end
  public #paramName($prop)#questionMarkIfOptional($prop): #toSdkType($def.name, $prop, false);

#end
  /**
   * Creates a new `$def.name` object.
#foreach( $prop in $props )
   * @param #paramName($prop) - $str.formatDoc($prop.doc, "   * ")
#end
   */
#if ($use_object_params)
  constructor({
#else
  constructor(
#end
#foreach( $prop in $props )
#if ($use_object_params)
    #paramName($prop),
#else
    #paramName($prop)#questionMarkIfOptional($prop): #toSdkType($def.name, $prop, true),
#end
#end
#if ($use_object_params)
  }: {
#foreach ( $prop in $props )
    #paramName($prop)#questionMarkIfOptional($prop): #toSdkType($def.name, $prop, true)

#end
  }) {
#else
  ) {
#end
#foreach( $prop in $props )
#set( $var = "#paramName($prop)" )
    this.$var = #constructorAssignType($def.name, $prop);
#end
  }

  msgpackPrepare(): Map<string, MsgpackEncodingData> {
    const data = new Map<string, MsgpackEncodingData>([
#foreach( $prop in $props )
#if ( $prop.required )
    ['$prop.propertyName', #msgpackPrepareField($prop)],
#end
#end
    ]);
#foreach( $prop in $props )
#if ( ! $prop.required )
    if (#shouldMsgpackPrepareOptionalField($prop)) {
      data.set('$prop.propertyName', #msgpackPrepareField($prop));
    }
#end
#end
    return data;
  }

  jsonPrepare(): Record<string, JSONEncodingData> {
    const obj: Record<string, JSONEncodingData> = {};

    /* eslint-disable dot-notation */
#foreach( $prop in $props )
#if ( $prop.required )
    obj['$prop.propertyName'] = #jsonPrepareField($def.name, $prop);
#else
    if (#shouldMsgpackPrepareOptionalField($prop)) {
      obj['$prop.propertyName'] = #jsonPrepareField($def.name, $prop);
    }
#end
#end
    /* eslint-enable dot-notation */

    return obj;
  }

  static fromDecodedJSON(encoded: unknown): $def.name {
    if (encoded === null || typeof encoded !== 'object') {
#set($d = "$")
      throw new Error(`Invalid decoded $def.name: ${d}{encoded}`);
    }
    const data = encoded as Record<string, any>;
    /* eslint-disable dot-notation */
#if ($use_object_params)
    return new ${def.name}({
#foreach( $prop in $props )
      #paramName($prop): #fromDecodedJSONAssignType("data['$prop.propertyName']", $prop, $def.name),
#end
    });
#else
    return new ${def.name}(
#foreach( $prop in $props )
      #fromDecodedJSONAssignType("data['$prop.propertyName']", $prop, $def.name),
#end
    );
#end
    /* eslint-enable dot-notation */
  }

  static fromDecodedMsgpack(data: unknown): $def.name {
#set ( $d = "$" )## Create a variable in order to insert a $ into the code
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded logic sig account: ${d}{data}`);
    }
#if ($use_object_params)
    return new ${def.name}({
#foreach( $prop in $props )
      #paramName($prop): #fromDecodedMsgpackAssignType("data.get('$prop.propertyName')", $prop, $def.name),
#end
    });
#else
    return new ${def.name}(
#foreach( $prop in $props )
      #fromDecodedMsgpackAssignType("data.get('$prop.propertyName')", $prop, $def.name),
#end
    );
#end
  }
}

#end
