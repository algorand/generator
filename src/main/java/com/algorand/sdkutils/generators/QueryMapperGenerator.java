package com.algorand.sdkutils.generators;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.AbstractMap.SimpleEntry;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map.Entry;
import com.algorand.sdkutils.utils.Tools;
import com.algorand.sdkutils.utils.TypeDef;
import com.fasterxml.jackson.databind.JsonNode;

public class QueryMapperGenerator extends OpenApiParser {

    JsonNode indexer;
    JsonNode algod;
    @SuppressWarnings("deprecation")
    public QueryMapperGenerator(JsonNode indexerRoot, JsonNode algodRoot) {
        super(indexerRoot);
        this.indexer = indexerRoot;
        this.algod = algodRoot;
    }

    public void writeQueryMapper(String sdkutilsPath) throws IOException {
        BufferedWriter bw = Tools.getFileWriter("QueryMapper", sdkutilsPath);
        bw.append("/*\n" +
                " *     THIS FILE IS GENERATED BY QueryMapperGenerator!!!!!!!!!!!!!!!! \n" +
                " */\n" +
                "package com.algorand.algosdk.unit.utils;\n\n" + 
                "import java.security.NoSuchAlgorithmException;\n" + 
                "import com.fasterxml.jackson.core.JsonProcessingException;\n" +

                "import java.text.ParseException;\n" + 
                "import java.util.ArrayList;\n\n" +
                
                "import com.algorand.algosdk.v2.client.common.Utils;\n" + 
                "\n" + 
                "import com.algorand.algosdk.crypto.Address;\n" + 
                "import com.algorand.algosdk.util.Encoder;\n" +
                "import com.algorand.algosdk.v2.client.algod.*;\n" +
                "import com.algorand.algosdk.v2.client.indexer.*;\n" + 
                "import com.algorand.algosdk.v2.client.model.Enums;\n" + 
                "import com.algorand.algosdk.v2.client.common.*;\n\n" + 
                "public class QueryMapper {\n" + 
                "\n");

        StringBuffer getClass = new StringBuffer();
        StringBuffer setValue = new StringBuffer();
        StringBuffer lookUp = new StringBuffer();
        StringBuffer enumMappers = new StringBuffer();

        setValue.append("    public static void setValue(Query q, String className, String property, String value) throws ParseException, NoSuchAlgorithmException, JsonProcessingException {\n" + 
                "        switch (className) {\n");
        lookUp.append("    public static String lookup(Query q, String className) throws Exception {\n" + 
                "        Response<?> resp = q.execute();\n" + 
                "        if (resp.body() == null) {\n" + 
                "            throw new RuntimeException(resp.message());\n" + 
                "        }\n" + 
                "        return resp.body().toString();\n" + 
                "    }\n\n");

        this.root = indexer;
        getClass.append("    public static Query getClass(String name, IndexerClient client, String args[]) throws NoSuchAlgorithmException {\n" + 
                "        switch (name) {\n");
        JsonNode paths = this.root.get("paths");
        Iterator<Entry<String, JsonNode>> pathIter = paths.fields();
        HashSet<Entry<String, JsonNode>> additionalEnums = new HashSet<Entry<String, JsonNode>> ();
        while (pathIter.hasNext()) {
            additionalEnums.add(getMappings(getClass, setValue, pathIter));
        }
        getClass.append("        }\n" + 
                "        return null;\n" + 
                "    }\n\n");

        this.root = algod;
        getClass.append("    public static Query getClass(String name, AlgodClient client, String args[]) throws NoSuchAlgorithmException {\n" + 
                "        switch (name) {\n");
        paths = this.root.get("paths");
        pathIter = paths.fields();
        while (pathIter.hasNext()) {
            additionalEnums.add(getMappings(getClass, setValue, pathIter));
        }

        getClass.append("        }\n" + 
                "        return null;\n" + 
                "    }\n\n");
        setValue.append("\n" + 
                "        }\n" + 
                "    }\n\n");

        generateEnumMapper(root, enumMappers);
        for (Entry<String, JsonNode> e : additionalEnums) {
            if (e == null)
                continue;
            enumMappers.append(getEnumClsssDef(e.getKey(), e.getValue()));
        }
        bw.append(getClass);
        bw.append(setValue);
        bw.append(lookUp);
        bw.append(enumMappers);
        bw.append("}");
        bw.close();
    }

    private Entry<String, JsonNode> getMappings(StringBuffer getClass, StringBuffer setValue,
            Iterator<Entry<String, JsonNode>> pathIter) {
        Entry<String, JsonNode> returnEnumDef = null;
        Entry<String, JsonNode> path = pathIter.next();
        JsonNode privateTag = path.getValue().get("post") != null ? path.getValue().get("post").get("tags") : null;
        if (privateTag != null && privateTag.elements().next().asText().equals("private")) {
            return returnEnumDef;
        }
        String className = path.getValue().findValue("operationId").asText();
        String javaClassName = Tools.getCamelCase(className, true);
        /*
         * TODO: this is a bug: function name should start with a small letter.
         * However, v2 was released with function names first letter cap. 
         * Will be good to fix in the future. 
         * 
         * Should use:  getCamelCase(className, false);
         */
        String methodName = Tools.getCamelCase(className, Character.isUpperCase(className.charAt(0)));

        // getClass
        getClass.append("        case \""+className+"\":\n" + 
                "            return client."+methodName+"(");

        //setValue
        setValue.append("        case \""+className+"\":\n" + 
                "            switch (property) {\n");

        JsonNode paramNode = path.getValue().findValue("parameters");
        Iterator<Entry<String, JsonNode>> properties = getSortedParameters(null, paramNode);

        // The parameters in the path are directly passed to the constructor.
        // The method with have in order arguments each assigned to the parameter in order. 
        int argCounter = 0;

        while (properties.hasNext()) {
            Entry<String, JsonNode> parameter = properties.next();
            String javaSetParamName = Tools.getCamelCase(parameter.getKey(), false);

            JsonNode typeNode = parameter.getValue().get("type") != null ? parameter.getValue() : parameter.getValue().get("schema");
            if (typeNode.get("$ref") != null) {
                typeNode = this.getFromRef(typeNode.get("$ref").asText());            
            }
            String typeName = typeNode.get("type").asText();
            Iterator<JsonNode> enumVals = parameter.getValue().get("enum") == null ? null : 
                parameter.getValue().get("enum").elements();
            String javaEnumName = Tools.getCamelCase(parameter.getKey(), true);
            javaEnumName = Tools.getCamelCase(parameter.getKey(), true);
            
            String format = OpenApiParser.getTypeFormat(typeNode, parameter.getKey());

            if (inPath(parameter.getValue())) {
                if (argCounter > 0) {
                    getClass.append(", ");
                }
                switch (typeName) {
                case "integer":
                    getClass.append("Long.valueOf("+"args[" + argCounter + "])");
                    break;
                case "string":
                    if (format.contentEquals("Address")) {
                        getClass.append("new Address(args[" + argCounter + "])");
                        break;
                    }
                    getClass.append("args[" + argCounter + "]");
                    break;
                case "boolean":
                    getClass.append("Boolean.valueOf("+"args[" + argCounter + "])");
                    break;
                default:
                    throw new RuntimeException("Unknow type: " + typeName);
                }

                argCounter++;
                continue;
            }
            // Do not expose format property
            if (javaEnumName.equals("Format")) {
                continue;
            }
            setValue.append("            case \""+parameter.getKey()+"\":\n");
            if (typeName.compareTo("array") != 0) {
                setValue.append("                (("+javaClassName+")q)."+javaSetParamName+"(");
            }
            switch (typeName) {
            case "object": 
                setValue.append("null);\n");
                break;
            case "integer":
                setValue.append("Long.valueOf(value));\n");
                break;
            case "array": // case of array of enums. If another type is introduced, updated this
                returnEnumDef  = new SimpleEntry<String, JsonNode>(javaEnumName, typeNode);
                setValue.append("                ArrayList<Enums." + javaEnumName + "> vals = new ArrayList<Enums." + javaEnumName + ">();\n");
                setValue.append("                for (String t : value.split(\",\")) {\n");
                setValue.append("                       vals.add(getExclude(t));\n                }\n");
                setValue.append("                ((SearchForAccounts)q).exclude(vals);\n");
                break;
            case "string":
                switch (format) {
                case "RFC3339 String":
                    setValue.append("Utils.parseDate(value));\n");
                    break;
                case "Address":
                    setValue.append("new Address(value));\n");
                    break;
                case "byte":
                case "binary":
                    setValue.append("Encoder.decodeFromBase64(value));\n");
                    break;
                default:
                    if (enumVals != null) {
                        setValue.append("get" + javaEnumName + "(value));\n");
                    } else {
                        setValue.append("value);\n");
                    }
                }
                break;
            case "boolean":
                setValue.append("Boolean.valueOf(value));\n");
                break;
            default:
                throw new RuntimeException("Unhandled type: " + typeName);

            }
            setValue.append("                break;\n");
        }
        getClass.append(");\n");
        setValue.append("            }\n            break;\n");
        return returnEnumDef;
    }

    private void generateEnumMapper (JsonNode root, StringBuffer enumMappers) throws IOException {
        JsonNode parameters = root.get("parameters");
        Iterator<Entry<String, JsonNode>> classes = parameters.fields();
        while (classes.hasNext()) {
            Entry<String, JsonNode> cls = classes.next();
            if (cls.getValue().get("enum") != null) {
                // Do not expose format property
                if (cls.getKey().equals("format")) {
                    continue;
                }
                enumMappers.append(getEnumClsssDef(cls.getKey(), cls.getValue()));
            }
        }
    }

    public static String getEnumClsssDef (String name, JsonNode node) {
        StringBuffer sb = new StringBuffer();
        String enumName = Tools.getCamelCase(name, true);
        TypeDef enumType = getEnum(node, name, "", "", "", "", "", "", "");
        sb.append("    public static " + enumType.javaTypeName + " get" + enumName + "(String val) {\n");
        sb.append("        switch(val.toUpperCase()) {\n");
        for (String val : enumType.enumValues) {
            String javaEnum = Tools.getCamelCase(val, true).toUpperCase();
            sb.append("        case \"" + javaEnum + "\":\n");
            sb.append("            return " + enumType.javaTypeName + "." + javaEnum + ";\n");
        }
        sb.append("        default:\n            throw new RuntimeException(\"Enum value not recognized: \" + val +\"!\");\n");
        sb.append("        }\n    }\n");
        return sb.toString();
    }
}
